# Copyright (c) 2019 Teradici Corporation
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

$LOG_FILE = "C:\Teradici\provisioning.log"

$DECRYPT_URI = "https://cloudkms.googleapis.com/v1/${kms_cryptokey_id}:decrypt"

$METADATA_HEADERS = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$METADATA_HEADERS.Add("Metadata-Flavor", "Google")

$METADATA_BASE_URI = "http://metadata.google.internal/computeMetadata/v1/instance"
$METADATA_AUTH_URI = "$($METADATA_BASE_URI)/service-accounts/default/token"

$DATA = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$DATA.Add("pcoip_registration_code", "${pcoip_registration_code}")
$DATA.Add("admin_password", "${admin_password}")
$DATA.Add("service_account_password", "${service_account_password}")

function Get-AuthToken {
    try {
        $response = Invoke-RestMethod -Method "Get" -Headers $METADATA_HEADERS -Uri $METADATA_AUTH_URI
        return $response."access_token"
    }
    catch {
        "Error fetching auth token: $_"
        return $false
    }
}

function Decrypt-Credentials {
    $token = Get-AuthToken

    if(!($token)) {
        return $false
    }

    $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
    $headers.Add("Authorization", "Bearer $($token)")

    try {
        $resource = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $resource.Add("ciphertext", "${pcoip_registration_code}")
        $response = Invoke-RestMethod -Method "Post" -Headers $headers -Uri $DECRYPT_URI -Body $resource
        $credsB64 = $response."plaintext"
        $DATA."pcoip_registration_code" = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($credsB64))

        $resource = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $resource.Add("ciphertext", "${admin_password}")
        $response = Invoke-RestMethod -Method "Post" -Headers $headers -Uri $DECRYPT_URI -Body $resource
        $credsB64 = $response."plaintext"
        $DATA."admin_password" = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($credsB64))

        $resource = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $resource.Add("ciphertext", "${service_account_password}")
        $response = Invoke-RestMethod -Method "Post" -Headers $headers -Uri $DECRYPT_URI -Body $resource
        $credsB64 = $response."plaintext"
        $DATA."service_account_password" = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($credsB64))
    }
    catch {
        "Error decrypting credentials: $_"
        return $false
    }
}

Start-Transcript -path $LOG_FILE -append

if (test-path "C:\Nvidia") {
    exit
}

if ([string]::IsNullOrWhiteSpace("${kms_cryptokey_id}")) {
    "Not using encryption"
} else {
    "Using ecnryption key ${kms_cryptokey_id}"
    Decrypt-Credentials
}

net user Administrator $DATA."admin_password" /active:yes

[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

"################################################################"
"Downloading NVIDIA GRID Driver..."
"################################################################"
mkdir 'C:\Nvidia'
$driverDirectory = "C:\Nvidia"
$driverUrl = "${nvidia_driver_location}" + "${nvidia_driver_filename}"
$destFile = $driverDirectory + "\" + "${nvidia_driver_filename}"
(New-Object System.Net.WebClient).DownloadFile($driverUrl, $destFile)
"NVIDIA GRID Driver downloaded"

"################################################################"
"Installing NVIDIA GRID Driver..."
"################################################################"
$ret = Start-Process -FilePath $destFile -ArgumentList "/s /noeula /noreboot" -PassThru -Wait
"NVIDIA GRID Driver installed"

"################################################################"
"Downloading Teradici PCoIP Agent..."
"################################################################"
mkdir 'C:\Teradici'
$agentInstallerDLDirectory = "C:\Teradici"
if ("${pcoip_agent_filename}") {
    $agent_filename = "${pcoip_agent_filename}"
} else {
    $agent_filename = (New-Object System.Net.WebClient).DownloadString("${pcoip_agent_location}latest-graphics-agent.json") | ConvertFrom-Json | Select-Object -ExpandProperty "filename"
}
$pcoipAgentInstallerUrl = "${pcoip_agent_location}$agent_filename"
$destFile = $agentInstallerDLDirectory + '\' + $agent_filename
(New-Object System.Net.WebClient).DownloadFile($pcoipAgentInstallerUrl, $destFile)
"Teradici PCoIP Agent downloaded: $agent_filename"

"################################################################"
"Installing Teradici PCoIP Agent..."
"################################################################"
$ret = Start-Process -FilePath $destFile -ArgumentList "/S /nopostreboot" -PassThru -Wait
"Teradici PCoIP Agent installed"

"################################################################"
"Registering PCoIP Agent..."
"################################################################"
cd 'C:\Program Files\Teradici\PCoIP Agent'
& .\pcoip-register-host.ps1 -RegistrationCode $DATA."pcoip_registration_code"
"PCoIP Agent Registered"

"################################################################"
"Joining Domain ${domain_name}..."
"################################################################"
$username = "${service_account_username}" + "@" + "${domain_name}"
$password = ConvertTo-SecureString $DATA."service_account_password" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential ($username, $password)

# Looping in case Domain Controller is not yet available
$Interval = 10
$Timeout = 600
$Elapsed = 0

do {
    Try {
        $Retry = $false
        # Don't do -Restart here because there is no log showing the restart
        Add-Computer -DomainName "${domain_name}" -Credential $cred -Verbose -Force -ErrorAction Stop
    }

    # The same Error, System.InvalidOperationException, is thrown in these cases: 
    # - when Domain Controller not reachable (retry waiting for DC to come up)
    # - when password is incorrect (retry because user might not be added yet)
    # - when computer is already in domain
    Catch [System.InvalidOperationException] {
        $_.Exception.Message
        if (($Elapsed -ge $Timeout) -or ($_.Exception.GetType().FullName -match "AddComputerToSameDomain,Microsoft.PowerShell.Commands.AddComputerCommand")) {
            exit
        }

        "Retrying in $Interval seconds... (Timeout in $($Timeout-$Elapsed) seconds)"
        $Retry = $true
        Start-Sleep -Seconds $Interval
        $Elapsed += $Interval
    }
    Catch {
        $_.Exception.Message
        exit
    }
} while ($Retry)

"################################################################"
"Restarting computer..."
"################################################################"
Restart-Computer -Force
