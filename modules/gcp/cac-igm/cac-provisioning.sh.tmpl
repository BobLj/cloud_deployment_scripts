# Copyright (c) 2019 Teradici Corporation
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

#!/bin/bash

LOG_FILE="/var/log/teradici/provisioning.log"

INSTALL_DIR="/root"
CAC_INSTALL_LOG="/var/log/teradici/cac-install.log"
cd $INSTALL_DIR

METADATA_BASE_URI="http://metadata.google.internal/computeMetadata/v1/instance"
METADATA_AUTH_URI="$METADATA_BASE_URI/service-accounts/default/token"
DECRYPT_URI="https://cloudkms.googleapis.com/v1/${kms_cryptokey_id}:decrypt"

PCOIP_NETWORK_CONF_FILE="/etc/sysctl.d/01-pcoip-cac-network.conf"

export DEBIAN_FRONTEND=noninteractive

log() {
    local message="$1"
    echo "[$(date)] $message"
}

retry() {
    local timeout=$1
    local interval=$2
    local command=$3
    local log_message=$4
    local err_message=$5

    until $command
    do
        if [ $timeout -le 0 ]
        then
            log $err_message
            break
        fi

        log "$log_message Retrying in $interval seconds... (Timeout in $timeout seconds)"

        timeout=$((timeout-interval))
        sleep $interval
    done
}

install_prereqs() {
    log "--> Installing dos2unix, python3..."
    apt-get -qq update
    apt install -y dos2unix python3

    if [ $? -ne 0 ]; then
        log "--> ERROR: Failed to install dos2unix, python3. Exiting provisioning script..."
        exit 1
    fi
}

get_credentials() {
    # Disable logging of secrets by wrapping the region with set +x and set -x
    set +x
    log "--> Downloading CAM Deployment Service Account JSON file from the bucket..."
    gsutil cp gs://${bucket_name}/${cam_deployment_sa_file} $INSTALL_DIR

    if [[ -z "${kms_cryptokey_id}" ]]; then
        log "--> Script is not using encryption for secrets."

        PCOIP_REGISTRATION_CODE=${pcoip_registration_code}
        AD_SERVICE_ACCOUNT_PASSWORD=${ad_service_account_password}

    else
        log "--> Script is using encryption key: ${kms_cryptokey_id}"

        # Gets access token attribute of response json object
        token=$(curl "$METADATA_AUTH_URI" -H "Metadata-Flavor: Google" | python3 -c "import sys, json; print(json.load(sys.stdin)['access_token'])")

        # Gets data using access token and decodes it
        log "--> Decrypting PCoIP registration code..."
        data=$(echo "{ \"ciphertext\": \"${pcoip_registration_code}\" }")
        b64_data=$(curl -X POST -d "$data" "$DECRYPT_URI" -H "Authorization: Bearer $token" -H "Content-type: application/json" | python3 -c "import sys, json; print(json.load(sys.stdin)['plaintext'])")
        PCOIP_REGISTRATION_CODE=$(echo "$b64_data" | base64 --decode)

        log "--> Decrypting AD service account password..."
        data=$(echo "{ \"ciphertext\": \"${ad_service_account_password}\" }")
        b64_data=$(curl -X POST -d "$data" "$DECRYPT_URI" -H "Authorization: Bearer $token" -H "Content-type: application/json" | python3 -c "import sys, json; print(json.load(sys.stdin)['plaintext'])")
        AD_SERVICE_ACCOUNT_PASSWORD=$(echo "$b64_data" | base64 --decode)

        log "--> Decrypting CAM Deployment Service Account JSON file..."
        cam_cred_encrypted=$(cat $INSTALL_DIR/${cam_deployment_sa_file})
        data=$(echo "{ \"ciphertext\": \"$cam_cred_encrypted\" }")
        b64_data=$(curl -X POST -d "$data" "$DECRYPT_URI" -H "Authorization: Bearer $token" -H "Content-type: application/json" | python3 -c "import sys, json; print(json.load(sys.stdin)['plaintext'])")
        CAM_CREDENTIALS=$(echo "$b64_data" | base64 --decode)
        echo $CAM_CREDENTIALS > $INSTALL_DIR/${cam_deployment_sa_file}
    fi
    set -x
}

get_cac_token() {
    log "--> Retrieving connector token before CAC install..."

    log "--> Downloading CAM python script from the bucket..."
    gsutil cp gs://${bucket_name}/${cam_script} $INSTALL_DIR
    chmod +x $INSTALL_DIR/${cam_script}

    # Ensure line endings are in Unix format
    dos2unix $INSTALL_DIR/${cam_script}
    dos2unix $INSTALL_DIR/${cam_deployment_sa_file}

    # Set CAC_TOKEN variable using the script's output
    CAC_TOKEN=`$INSTALL_DIR/${cam_script} $INSTALL_DIR/${cam_deployment_sa_file} --url ${cam_url}/api/v1`

    # Check and exit startup script if retrieving connector token failed
    if [ $? -ne 0 ]; then
        log "--> ERROR: Failed to retrieve connector token using CAM script. Exiting provisioning script..."
        exit 1
    fi
}

check_required_vars() {
    set +x
    if [[ -z "$PCOIP_REGISTRATION_CODE" ]]; then
        log "--> ERROR: Missing PCoIP Registration Code."
        missing_vars="true"
    fi

    if [[ -z "$AD_SERVICE_ACCOUNT_PASSWORD" ]]; then
        log "--> ERROR: Missing Active Directory Service Account Password."
        missing_vars="true"
    fi
    set -x

    if [[ -z "$CAC_TOKEN" ]]; then
        log "--> ERROR: Missing Cloud Access Connector Token."
        missing_vars="true"
    fi

    if [[ "$missing_vars" = "true" ]]; then
        log "--> Exiting..."
        exit 1
    fi
}

check_connector_installed() {
    if [[ -f "$INSTALL_DIR/cloud-access-connector" ]]; then
        log "--> Connector already installed. Skipping provisioning script..."
        exit 0
    fi
}

config_network() {
    if [[ ! -f $PCOIP_NETWORK_CONF_FILE ]]; then
        log "--> Configuring network..."
        # Note the indented HEREDOC lines must be preceded by tabs, not spaces
        cat <<- EOF > $PCOIP_NETWORK_CONF_FILE
			# System Control network settings for CAC
			net.core.rmem_max=160000000
			net.core.rmem_default=160000000
			net.core.wmem_max=160000000
			net.core.wmem_default=160000000
			net.ipv4.udp_mem=120000 240000 600000
			net.core.netdev_max_backlog=2000
			EOF
        
        sysctl -p $PCOIP_NETWORK_CONF_FILE
    fi
}

download_cac() {
    log "--> Downloading CAC installer..."
    curl -L ${cac_installer_url} -o $INSTALL_DIR/cloud-access-connector.tar.gz
    tar xzvf $INSTALL_DIR/cloud-access-connector.tar.gz
}

wait_for_dc() {
    local timeout=25
    local interval=5

    # Wait for service account to be added. Do this last because it takes
    # a while for new AD user to be added in a new Domain Controller.
    # Note: using the domain controller IP instead of the domain name for
    #       the host is more resilient.

    log "--> Updating apt-get package list..."
    retry $timeout \
          $interval \
          "apt-get -qq update" \
          "--> Updating apt-get package list..." \
          "--> ERROR: Failed to update apt-get package list."

    log "--> Installing ldap_utils..."
    retry $timeout \
          $interval \
          "apt-get -qq install ldap-utils" \
          "--> Installing ldap_utils..." \
          "--> ERROR: Failed to install ldap-utils."

    timeout=1200
    interval=10

    set +x
    log "--> Ensure AD account is available..."
    retry $timeout \
          $interval \
          "ldapwhoami \
            -H ldap://${domain_controller_ip} \
            -D ${ad_service_account_username}@${domain_name} \
            -w $AD_SERVICE_ACCOUNT_PASSWORD \
            -o nettimeout=1" \
          "--> Waiting for AD account ${ad_service_account_username}@${domain_name} to become available." \
          "--> ERROR: Timed out waiting for AD account ${ad_service_account_username}@${domain_name} to become available. Continuing..."
    set -x
    # Check that the domain name can be resolved and that the LDAP port is accepting
    # connections. This could have been all done with the ldapwhoami command, but
    # due to a number of occasional cac-installation issues, such as "domain
    # controller unreachable" or "DNS error occurred" errors, check these explicitly
    # for logging and debug purposes.
    log "--> Ensure domain ${domain_name} can be resolved..."
    retry $timeout \
          $interval \
          "host ${domain_name}" \
          "--> Trying to resolve ${domain_name}." \
          "--> ERROR: Timed out trying to resolve ${domain_name}. Continuing..."

    log "--> Ensure domain ${domain_name} port 636 is reacheable..."
    retry $timeout \
          $interval \
          "netcat -vz ${domain_name} 636" \
          "--> Trying to contact ${domain_name}:636." \
          "--> ERROR: Timed out trying to contact ${domain_name}:636. Continuing..."
}

install_cac() {
    log "--> Installing Cloud Access Connector..."
    local retries=10
    export CAM_BASE_URI=${cam_url}

    log "--> Running command: $INSTALL_DIR/cloud-access-connector install"
    log "--> CAC install options:"
    log "-t <cac_token> --accept-policies"
    log "--sa-user <ad_service_account_username> --sa-password <ad_service_account_password>"
    log "--domain ${domain_name} --domain-group ${domain_group}"
    log "--reg-code <pcoip_registration_code> --sync-interval 5"

    # Set pipefail option to return status of the connector install command
    set -o pipefail

    set +x
    if [ -z "${ssl_key}" ]; then
        log "--insecure"

        while true
        do
            $INSTALL_DIR/cloud-access-connector install \
                -t $CAC_TOKEN \
                --accept-policies \
                --insecure \
                --sa-user ${ad_service_account_username} \
                --sa-password "$AD_SERVICE_ACCOUNT_PASSWORD" \
                --domain ${domain_name} \
                --domain-group "${domain_group}" \
                --reg-code $PCOIP_REGISTRATION_CODE \
                --retrieve-agent-state true \
                --sync-interval 5 \
                2>&1 | tee -a $CAC_INSTALL_LOG
            
            local rc=$?
            if [ $rc -eq 0 ]
            then
                log "--> Successfully installed Cloud Access Connector."
                break
            fi

            if [ $retries -eq 0 ]
            then
                log "--> ERROR: Failed to install Cloud Access Connector. No retries remaining."
                exit 1
            fi

            log "--> ERROR: Failed to install Cloud Access Connector. $retries retries remaining..."
            retries=$((retries-1))
            sleep 60
        done
    else
        log "--ssl-key <ssl_key> --ssl-cert <ssl_cert>"
        gsutil cp gs://${bucket_name}/${ssl_key} $INSTALL_DIR
        gsutil cp gs://${bucket_name}/${ssl_cert} $INSTALL_DIR

        while true
        do
            $INSTALL_DIR/cloud-access-connector install \
                -t $CAC_TOKEN \
                --accept-policies \
                --ssl-key $INSTALL_DIR/${ssl_key} \
                --ssl-cert $INSTALL_DIR/${ssl_cert} \
                --sa-user ${ad_service_account_username} \
                --sa-password "$AD_SERVICE_ACCOUNT_PASSWORD" \
                --domain ${domain_name} \
                --domain-group "${domain_group}" \
                --reg-code $PCOIP_REGISTRATION_CODE \
                --retrieve-agent-state true \
                --sync-interval 5 \
                2>&1 | tee -a $CAC_INSTALL_LOG
            
            local rc=$?
            if [ $rc -eq 0 ]
            then
                log "--> Successfully installed Cloud Access Connector."
                break
            fi

            if [ $retries -eq 0 ]
            then
                log "--> ERROR: Failed to install Cloud Access Connector. No retries remaining."
                exit 1
            fi

            log "--> ERROR: Failed to install Cloud Access Connector. $retries retries remaining..."
            retries=$((retries-1))
            sleep 60
        done
    fi
    set -x
}

if [[ ! -f "$LOG_FILE" ]]
then
    mkdir -p "$(dirname $LOG_FILE)"
    touch "$LOG_FILE"
    chmod +644 "$LOG_FILE"
fi

log "$(date)"

# Print all executed commands to the terminal
set -x

# Redirect stdout and stderr to the log file
exec &>>$LOG_FILE

install_prereqs

get_credentials

get_cac_token

check_required_vars

check_connector_installed

config_network

download_cac

wait_for_dc

install_cac

docker service ls

log "--> Provisioning script completed successfully. "
